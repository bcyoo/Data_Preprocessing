# -*- coding: utf-8 -*-
"""python_기초복습.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1varybZjUiowHtpbN4bdo2xYl6J_ds9Q0
"""

print('DeepLearning Bro!')

## int

a = 1
b = 0
c = -1

print(a, type(a))
print(b, type(b))
print(c, type(c))

d = a + b
print (d)

print(a+b)

## float

a = 1.2
b = 2.4
c = 0

print(a)

## 2진수로 계산하고 10진수로 변경하여서 3.59999로 출력됨
print(a+b)

print(a, type(a))
print(b, type(b))
print(c, type(c))

## str

a = 'deep '
b = 'learning'
print(type(a), type(b))

## str은 덧셈
print (a+b)

## bool

# True and False

a = True
b = False

print(type(a),type(b))

## 숫자형 문자
a = 1

b = '1'

print(type(a))
print(type(b))

c = int(b)
print(c, type(c))

#list

list1 = [1, 2, 3, 4]
print(list1, type(list1))

#element
print(list1[0])
print(list1[1])
print(list1[2])
print(list1[3])
print(list1[-1])
print(list1[-2])

# tuple
a = (1, 2)   tuple은 한번 선언하면 변경이 불가능함.
print(a, type(a))
print(a[0])
print(a[1])

#dict

a = {'class': ['deep learning', 'machine learning'], 'students': [40,20]}
print(a)

print(a['class'])

print(a['students'])

print(a['students'][0])

## numpy 배열   
## numpy는 다양한 연산들을 제공하여 데이터 분석에 있어 가장 기본이 되는 라이브러리이다.

import numpy as np

arr = np.array([1,2,3,4])
print(arr, type(arr))

from numpy import array, ones, zeros

a = array([1,2,3,4])
b = ones(5)
c = zeros((5,2))

print(a)
print(b)
print(c)

## 조건문

x = 10

if x == 1:
    print ('x = 1')
else:
    print('x != 1')

x = 1

if x ==1:
    print ('x는 1 입니다.')
elif x ==2:
    print ('x는 2 입니다.')
elif x ==3:
    print ('x는 3 입니다.')
else:
    print ('x는 4 입니다')

for i in range(5):   ## range(5) = [0, 1, 2, 3, 4] list
    print (i)

i = 0
while i < 5 :  # i가 0 일때 5보다 작으면 계쏙 돌림
    print(i)
    i+= 1  # i = i+1

# a * x ** 2 + b * x + c = 0
# [a, b, c] 라고 표현
f = np.random.randint(10, size=(10,3))
print(f)

for g in f:
    if g[0] ==0:
        print('이차 방정식이 아닙니다.')
    else:
        D = g[1]**2 -4*g[0]*g[2]
        if D==0:
            print('서로 같은 두 실근')
        elif D > 0:
            print('서로 다른 두 실근')
        else:
            print('서로 다른 두 허근')

## break문

pending = [1, 3, 5, 3, 8, 1, 4, 5]

for i in pending:
    if i % 2 == 0:
        print(i,'짝수')
        break

for i in pending:
    if i % 2 == 0:
        print('짝수')
    else:
        print(i,'홀수')
        break

## trp-excpet

x = [1,2, 3, 's', 4, 5]

for i in x:
    try:
        y = i + 1
        print(y)
    except:
        print(i, '는 오류입니다.')

# 함수

def negative(arr):  ## negative(함수값)
    
    
    ## np.where 특정 조건을 만족하는 원소의 위치를 알려주는 함수
    ## 
    count = len(np.where(arr < 0)[0]) # np.where(arr < 0)[0] -> [1,2,3,4] 
    print(f'해당 배열 안에 음수가 {count}개 있습니다.')

arr1 = np.array([0, -2, -3, -5, -6])
arr2 = np.array([0, 2, 3, 5, 6])

negative(arr1)
negative(arr2)

## 목적 함수 정의

def objecttive_function(x):
    return np.sin(x)+np.cos(x)+.5*np.exp(x)

y1 = objecttive_function(arr1)
y2 = objecttive_function(arr2)

print(y1)
print(y2)

## 데이터 요약
# 각 열의 평균
# 각 열의 표준편차
# 각 열의 최댓값
# 각 열의 최솟값
# 이상치 갯수 확인

def data_description(data):

    cmax = np.max(data, axis=0)
    cmin = np.min(data, axis=0)
    cmean = np.mean(data, axis=0)
    cstd = np.std(data, axis=0)
    outlier_idx = np.where(data[:,4]>100)[0]
    outlier1 = len(outlier_idx)

    print (f'인스턴스 개수는 {data.shape[0]}이고 변수의 개수는 {data.shape[1]}입니다.')
    print(f'x5 변수에 대한 이상치는 {outlier1}개 입니다.')

    return cmax, cmin, cmean, cstd

data1 = np.random.randint(0,105, size=(100,20))
data2 = np.random.randint(0,105, size=(50,40))

cmax1, cmin1, cmean1, _ = data_description(data1)

cmax2, cmin2, cmean2, _ = data_description(data2)

from google.colab import drive
drive.mount('/content/gdrive')

cd/content/gdrive/MyDrive/deeplearningbro/python

## 모듈


import numpy as np

import models

data = np.random.randint(0,105, size=(10,5))

models.linear_regression(data)

models.gaussian_mixture(data)

models.random_forest(data)

## 클래스
# 어떤 하나의 기능을 구현하는데 여러개의 함수가 필요할 때가 있다.
# 이 때, 데이터와 세부적인 기능을 수행하는 함수들을 묶어서 구현할 수 있는데
# 이 때 기본적으로 사용되는 것이 클래스이다.
# 클래스는 상속 등의 다양한 기능을 통해 프로그램의 복잡도를 감소시켜 주며
# 확장에 매우 유리하게 자굥한다.
# 또한 중요 변수를 클래스에 넣어 외부의 변수들과 혼동 될 위험을 줄여준다.

import numpy as np
from matplotlib import pyplot as plt

data = np.random.normal(0,10,(100,1))
target = np.random.normal(0,1,100)

class LinearReg:  ## 함수들의 모임
    def __init__(self, data, target, scaling=False): ## __inint__을 통해 외부에서 값을 받을 수 있음
                # class 안에 있는 함수들은 self를 반드시 적고, 불러올 값들을 적어줌
        self.data = data
        self.target = target
        self.num_instances = self.data.shape[0] # 행의 갯수
        self.num_features = self.data.shape[1]  # 열의 개수
        self.scaling = scaling
        print(f'num_instances={self.num_instances}, num_features={self.num_features}, scaling={scaling}')

    def minmax(self): # 모든 변수를 0과 1사이로 만드는 scaling
        for i in range(self.num_features):
            col = self.data[:,i] # scaling 하기 위해선 feature와 데이터가 필요
            self.data[:,i] = (self.data[:,i]-np.min(col)) /(np.max(col)-np.min(col)) 
            ## minmax로 self data를 scaling 한 상태 
        return self # 메서드에서 self를 반환한다는 것은 단순히 메서드가 호출된 인스턴스 개체에 대한 참조를 반환 한다는 의미

    ## data processing
    ## data split
    
    def solver(self):

        if self.scaling == True: #True면 scaling 발동
            self.minmax()
        
        plt.plot(self.data, self.target, '.')
        plt.show()

m1 = LinearReg(data, target) # data와 target은 외부에서 받아서 사용.
m1.solver()

m2 = LinearReg(data, target, True) # True 일 경우 0과 1사이로 scaling
m2.solver()

# 그래프 그리기

import numpy as np
from matplotlib import pyplot as plt

## 딥러닝 때 얻는 대표적인 정보는 loss 정보
epoch = np.arange(1, 100) # 학습을 몇회 돌렸냐에 따라서 train_loss와 val_loss test_loss를 얻을 수 있음.
train_loss = 1.4/(epoch)
val_loss = .3+1/(epoch)

plt.figure(figsize=(10,5))
plt.plot(train_loss, 'r-*') #red에 *표시해서 연결
plt.plot(val_loss, 'b-*') #blue에 *표시해서 연결
plt.legend(['train', 'validation'])  # 범주표현
plt.title('MNIST')
plt.xlabel('epoch')
plt.ylabel('loss')
plt.show

plt.figure(figsize=(5,10))
t = np.arange(0., 5., 0.2)
plt.plot(t, t, 'ro', t, t**2, 'bs', t, 5*np.sin(t), 'g^')
## x, y 값 , 그래프 형태, x y 값 
plt.legend(['t', 't**2', '5sin(t)'])
plt.show()

## subplot

names = ['First', 'Business', 'Economy']

prices = [20, 5, 1]

plt.figure(figsize=(15,5))

plt.subplot(131)  ## 1행 3열에 1번째 그래프 #eg subplot(335)일 경우 3행 3열에 5번째 그래프 
plt.bar(names, prices)
plt.title(f'{names[0]}', fontsize=14)

plt.subplot(132)
plt.scatter(names, prices)
plt.xlabel('class',fontsize=12)

plt.subplot(133)
plt.plot(names, prices, linewidth=5.0)
plt.suptitle('Ticket Class', fontsize=14)
plt.axis('off')
plt.show()

