# -*- coding: utf-8 -*-
"""pytorch_커스텀데이터.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10G53iHYrOYfCF7CohTbjVBPpuJpwZbOp

3. 데이터 불러오기(심화)


    딥러닝을 포함한 머신러닝의 근원은 데이터다
    따라서 데이터의 수입,가공,사용 방법에 따라 모델 성능이 크게 달라질 수 있으며
    데이터의 형태는 매우 다양하기 때문에 데이터를 잘 불러오는 것은 가장 중요한 단계 중 하나다.

3.4 커스텀 데이터 + 커스텀 전처리
   
    이번에는 텐서 생성 부분에서 미지 전처리르 진행.
"""

import torch
import torchvision.transforms as tr # 이미지 전처리 기능들을 제공하는 라이브러리
from torch.utils.data import DataLoader, Dataset # 데이터를 모델에 사용할 수 있도록 정리해 주는 라이브러리
import numpy as np

# 32x32 컬러 이미지와 라벨이 각각 100장 있다고 가정
# glob로 데이터를  -> PIL, openCV로 불러올수 잇음
train_images = np.random.randint(255, size=(100,32,32,3)) # (이미지 수) x (너비) x (높이) x (채널 수) 
train_labels = np.random.randint(2, size=(100,1)) # 라벨 수

# 3.3에서 사용한 양식을 그대로 사양하되 전처리 작업을 할 수 있도록 transform을 추가한다.
# tensor을 만들고 transform하는 방법.
class MyDataset(Dataset):

    def __init__ (self, x_data, y_data, transform=None): # transform이 None이면 기본적으로 안하는 설정

        self.x_data = x_data # 넘파이 배열이 들어옴
        self.y_data = y_data # 넘파이 배열이 들어옴
        self.transform = transform
        self.len = len(y_data)

    def __getitem__ (self, index):
        sample = self.x_data[index], self.y_data[index]

        if self.transform:
               sample = self.transform(sample) # self.transform이 None이 아니라면 전처리 작업을 진행한다.

        return sample # 3.3과 다르게 넘파이 배열로 출력 되는 것에 유의해야함

    def __len__(self):
        return self.len

# 전처리 기술을 직접 만들기
# 이 때 위 기본 양식과 같이 사용하기 위해 call 함수를 사용함
# def __call__ 내의 원한느 전처리 작업을 프로그래밍 할 수 있음.

# 1. 텐서 변환
class ToTensor:
    
    def __call__(sefl, sample):  ## sample을 가져와서 텐서로 변환하고 크기를 변환하기위해 call  함수를 씀
        
        inputs, labels = sample
        inputs = torch.FloatTensor(inputs) # 텐서로 변환
        inputs = inputs.permute(2, 0, 1) # 크기 변환   # 2(채널 수)x0(너비)x1(높이)
        return inputs, torch.LongTensor(labels) # 라벨을 롱텐서로 변환 

# 2. 선형식
class LinearTensor:

    def __init__ (self, slope=1, bias=0):
        self.slope = slope
        self.bias = bias
    
    def __call__ (self, sample):
        inputs, labels = sample
        inputs = self.slope*inputs + self.bias # ax+b 계산
        return inputs, labels

# .....
# 추가로 계쏙 전처리를 정희
# ....

# ToTensor()를 이용해서 위에 만든 class를 사용하는 것.
trans = tr.Compose ([ToTensor(), LinearTensor(2,5)]) # 텐서 변환 후 선형식 2x+5 연산
dataset1 = MyDataset(train_images, train_labels, transform=trans)
train_loader1 = DataLoader(dataset1, batch_size=10, shuffle=True)

# ToTensor()와 tr.ToTensor 차이
# 앞서 사용한 tr.ToTenseor()s는 import torchvision.transforms as tr을 이용한 파이토치 메소드를 이용한 것이고,
# ToTensor()은 위에서 정의된 메소드를 사용한 것

dataiter1 = iter(train_loader1)
images1, labels1 = dataiter1.next()
print(images1.size())

"""3.5 커스텀 데이터 + torchvision.transforms 전처리"""

# torchvision.transforms에서 제공하는 전처리 기술을 사용
# torchvision.transforms은 입력 이미지가 일반적으로  PILImage 타입이나 텐서일 경우에 동작
# 현재 데이터는 넘파이 배열, 따라서 텐서 변환 후 tr.ToPILImage()을 이용하여 PILImage 타입으로 만드ㅏㄹ어 준다
# __call__을 이용한 기본 구조는 동일.

class MyTransform:

    def __call__(self, sample):
        inputs, labels = sample
        inputs = torch.FloatTensor(inputs)
        inputs = inputs.permute(2,0,1)
        labels = torch.FloatTensor(labels)

        transf = tr.Compose([tr.ToPILImage(),
                             tr.Resize(128),
                             tr.ToTensor(),
                             tr.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))
                             ])
        final_output = transf(inputs)

        return final_output, labels

dataset2 = MyDataset(train_images, train_labels, transform=MyTransform())
train_loader2 = DataLoader(dataset2, batch_size = 15, shuffle = True)

dataiter2 = iter(train_loader2)
images2, labels2 = dataiter2.next()
print(images2.size()) # 배치 및 이미지 크기 확인

